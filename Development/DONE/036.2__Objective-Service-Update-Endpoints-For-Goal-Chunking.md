# üéØ Card 036.2 - Objective Service: Atualizar Endpoints para Goal Chunking

**Agente Respons√°vel:** Osvaldo  
**Microservi√ßo:** moversemais-objective  
**Prioridade:** Alta  
**Status:** TODO  
**Estimativa:** 4-6 horas

---

## üîç **ESTUDO PR√âVIO REALIZADO**

**Arquiobaldo estudou a aplica√ß√£o antes de criar este card:**
- ‚úÖ Leu `ObjectiveController.kt` (645 linhas)
- ‚úÖ Identificou 14 endpoints existentes
- ‚úÖ Verificou DTOs existentes (CreateObjectiveRequest, UpdateObjectiveRequest, ObjectiveResponse)
- ‚úÖ Verificou UseCases existentes (Create, Update, Get, List)
- ‚úÖ Sprint 1 COMPLETA - Novos campos: motive, context, mode
- ‚úÖ Card 035 COMPLETO - Goal Chunking implementado

---

## üìã CONTEXTO

### **Situa√ß√£o Atual**

**Sprint 1 e Card 035 COMPLETOS** ‚úÖ
- Campos novos em objectives: motive, context, mode
- Status DRAFT adicionado
- Entities: Stage, Action, KeyResult, ActionKrLink, Checkin
- Endpoint novo: POST /objectives/{id}/generate-plan

**Endpoints existentes DESATUALIZADOS** ‚ùå
- POST /objectives **N√ÉO aceita** motive, context, mode
- GET /objectives/{id} **N√ÉO retorna** stages, actions, key_results
- PUT /objectives/{id} **N√ÉO permite atualizar** motive, context
- DTOs desatualizados (n√£o incluem novos campos)

### **Problema Identificado**

Para que **Goal Chunking funcione end-to-end**, precisamos que:

**Frontend possa:**
- Criar meta com motive, context, mode (POST)
- Buscar meta com plano completo (GET)
- Atualizar motive e context (PUT)

**Atualmente:**
- ‚ùå Frontend n√£o consegue enviar motive, context, mode ao criar
- ‚ùå Frontend n√£o consegue buscar plano completo (stages, actions, KRs)
- ‚ùå Frontend n√£o consegue atualizar motive, context

**Resultado:**
- Goal Chunking n√£o funciona end-to-end
- BFF n√£o pode expor funcionalidade completa
- Frontend n√£o pode usar Goal Chunking

### **Solu√ß√£o Proposta**

Atualizar endpoints existentes para suportar Goal Chunking:
1. **POST /objectives** - Aceitar motive, context, mode
2. **GET /objectives/{id}** - Retornar plano completo
3. **PUT /objectives/{id}** - Permitir atualizar motive, context
4. **DTOs** - Adicionar novos campos

### **Onde se Encaixa na Arquitetura**

```
Sprint 2: Goal Chunking
‚îú‚îÄ Card 035: Backend Goal Chunking ‚úÖ DONE
‚îú‚îÄ Card 036: Seguran√ßa ‚úÖ DONE
‚îú‚îÄ Card 036.2: Atualizar Endpoints ‚Üê ESTE CARD
‚îú‚îÄ Card 037: BFF (Gabriela) ‚è∏Ô∏è Aguardando este card
‚îî‚îÄ Card 038: Frontend (Lisa) ‚è∏Ô∏è Aguardando 037
```

### **Impacto se N√£o For Feito**

- Frontend n√£o consegue criar metas com Goal Chunking
- BFF n√£o consegue expor funcionalidade completa
- Goal Chunking n√£o funciona end-to-end
- Sprint 2 incompleta

---

## üéØ REQUISITOS OBRIGAT√ìRIOS

### **1. Atualizar POST /objectives (Criar Meta)**

**Fun√ß√£o de Neg√≥cio:**
Permitir que usu√°rio crie meta com campos de Goal Chunking (motive, context, mode).

**Atualizar DTO:**
- **CreateObjectiveRequest** - Adicionar campos:
  - `motive: String?` (opcional)
  - `context: String?` (opcional)
  - `mode: String` (AUTO ou MANUAL) - DEFAULT: MANUAL

**L√≥gica de Neg√≥cio (CreateObjectiveUseCase):**
- Se `mode = AUTO`: criar com `status = DRAFT` (aguardando gera√ß√£o de plano)
- Se `mode = MANUAL`: criar com `status = ACTIVE` (meta sem plano)
- Validar mode (AUTO ou MANUAL)
- Salvar motive, context, mode no banco

**Comportamento:**
```
Modo AUTO:
- Frontend envia: {title, dates, type, motive, context, mode: AUTO}
- Backend cria: objective (status=DRAFT, mode=AUTO)
- Frontend chama: POST /objectives/{id}/generate-plan
- Backend gera plano e atualiza: status=ACTIVE

Modo MANUAL:
- Frontend envia: {title, dates, type, mode: MANUAL}
- Backend cria: objective (status=ACTIVE, mode=MANUAL)
- Meta criada sem plano (stages/actions/KRs vazios)
```

**Voc√™ decide:**
- Se valida motive/context obrigat√≥rios para mode=AUTO
- Mensagens de valida√ß√£o
- Logs

**Restri√ß√µes:**
- N√ÉO quebrar cria√ß√£o de metas existentes (backward compatible)
- N√ÉO alterar l√≥gica de valida√ß√£o existente (apenas adicionar campos)

---

### **2. Atualizar GET /objectives/{id} (Buscar Meta)**

**Fun√ß√£o de Neg√≥cio:**
Retornar meta completa incluindo plano (stages, actions, key_results) se existir.

**Atualizar DTO:**
- **ObjectiveResponse** - Adicionar campos:
  - `motive: String?`
  - `context: String?`
  - `mode: String`
  - `stages: List<StageDTO>?` (se tiver plano)
  - `keyResults: List<KeyResultDTO>?` (se tiver plano)

**StageDTO (criar se n√£o existir):**
```kotlin
data class StageDTO(
    val id: UUID,
    val title: String,
    val description: String?,
    val orderIndex: Int,
    val actions: List<ActionDTO>
)
```

**ActionDTO (criar se n√£o existir):**
```kotlin
data class ActionDTO(
    val id: UUID,
    val title: String,
    val description: String?,
    val status: String,
    val orderIndex: Int
)
```

**KeyResultDTO (criar se n√£o existir):**
```kotlin
data class KeyResultDTO(
    val id: UUID,
    val title: String,
    val description: String?,
    val type: String,
    val targetValue: BigDecimal,
    val currentValue: BigDecimal,
    val unit: String?,
    val weight: BigDecimal,
    val progressPercentage: Int
)
```

**L√≥gica de Neg√≥cio (GetObjectiveUseCase):**
- Buscar objective
- Buscar stages relacionados (StageRepository)
- Para cada stage, buscar actions (ActionRepository)
- Buscar key_results relacionados (KeyResultRepository)
- Montar estrutura hier√°rquica
- Retornar objective com plano completo

**Voc√™ decide:**
- Se usa fetch joins ou queries separadas
- Se cria DTOs novos ou reutiliza do Card 035 (GoalPlanDTO)
- Estrutura de mapeamento (Entity ‚Üí DTO)

**Restri√ß√µes:**
- N√ÉO quebrar busca de metas existentes
- N√ÉO causar N+1 queries (usar fetch joins ou queries otimizadas)

---

### **3. Atualizar PUT /objectives/{id} (Atualizar Meta)**

**Fun√ß√£o de Neg√≥cio:**
Permitir que usu√°rio atualize motive e context de uma meta existente.

**Atualizar DTO:**
- **UpdateObjectiveRequest** - Adicionar campos:
  - `motive: String?` (opcional)
  - `context: String?` (opcional)
  - **N√ÉO adicionar `mode`** (n√£o faz sentido mudar mode depois)

**L√≥gica de Neg√≥cio (UpdateObjectiveUseCase):**
- Permitir atualizar motive
- Permitir atualizar context
- **N√ÉO permitir** atualizar mode (imut√°vel ap√≥s cria√ß√£o)
- Validar ownership (j√° existe)

**Voc√™ decide:**
- Se valida algo espec√≠fico para motive/context
- Mensagens de valida√ß√£o

**Restri√ß√µes:**
- N√ÉO quebrar atualiza√ß√£o de metas existentes
- N√ÉO permitir atualizar mode

---

### **4. Atualizar DTOs de Listagem** üü°

**Endpoints de Listagem:**
- GET /objectives (lista geral)
- GET /objectives/active (ativos)
- GET /objectives/attention (em risco)
- GET /objectives/by-type/{type} (por tipo)
- GET /objectives/upcoming (pr√≥ximos)
- GET /objectives/search (busca)
- GET /objectives/stats (estat√≠sticas)

**Atualizar ObjectiveResponse:**
- Adicionar: motive, context, mode
- **N√ÉO adicionar** stages/actions/KRs (muito pesado para listas)

**Voc√™ decide:**
- Se cria DTO separado para listagem (ObjectiveListItemDTO)
- Ou usa ObjectiveResponse com stages/KRs opcionais

**Restri√ß√µes:**
- N√ÉO causar lentid√£o (listas devem ser r√°pidas)
- N√ÉO incluir plano completo em listagens (apenas em GET /{id})

---

## ‚ö†Ô∏è RESTRI√á√ïES

### **O que N√ÉO PODE ser alterado:**

1. ‚ùå **N√ÉO alterar entities** (Stage, Action, KeyResult, etc.)
2. ‚ùå **N√ÉO alterar repositories**
3. ‚ùå **N√ÉO alterar GoalChunkingService** (Card 035)
4. ‚ùå **N√ÉO alterar endpoint generate-plan** (Card 035)
5. ‚ùå **N√ÉO quebrar backward compatibility** (metas antigas continuam funcionando)
6. ‚ùå **N√ÉO causar N+1 queries** (usar fetch joins)

### **O que DEVE ser preservado:**

1. ‚úÖ **Padr√£o Clean Architecture** (Controller ‚Üí UseCase ‚Üí Repository)
2. ‚úÖ **Padr√£o de DTOs** (Request, Response)
3. ‚úÖ **Padr√£o de valida√ß√µes** (formato, ownership)
4. ‚úÖ **Padr√£o de exception handling**

---

## üìö DOCUMENTA√á√ÉO DE REFER√äNCIA

### **Arquivos para Estudar (OBRIGAT√ìRIO):**

1. **Controller Atual:**
   - `src/main/kotlin/com/moversemais/objective/controller/ObjectiveController.kt` (645 linhas)
   - 14 endpoints existentes

2. **DTOs Atuais:**
   - `src/main/kotlin/com/moversemais/objective/dto/CreateObjectiveRequest.kt`
   - `src/main/kotlin/com/moversemais/objective/dto/UpdateObjectiveRequest.kt`
   - `src/main/kotlin/com/moversemais/objective/dto/ObjectiveResponse.kt`

3. **UseCases Atuais:**
   - `src/main/kotlin/com/moversemais/objective/usecase/CreateObjectiveUseCase.kt`
   - `src/main/kotlin/com/moversemais/objective/usecase/UpdateObjectiveUseCase.kt`
   - `src/main/kotlin/com/moversemais/objective/usecase/GetObjectiveUseCase.kt`

4. **DTOs do Card 035:**
   - `src/main/kotlin/com/moversemais/objective/dto/goals/GoalPlanDTO.kt` (126 linhas)
   - Pode reutilizar StageDTO, ActionDTO, KeyResultDTO

5. **Repositories da Sprint 1:**
   - `StageRepository.kt`, `ActionRepository.kt`, `KeyResultRepository.kt`
   - Queries dispon√≠veis

6. **Mappers:**
   - `src/main/kotlin/com/moversemais/objective/mapper/ObjectiveMapper.kt`
   - Verificar se precisa atualizar

---

## üîß WORKFLOW

### **1. ESTUDAR (OBRIGAT√ìRIO - 1 hora)**

```bash
cd moversemais-objective

# Estudar controller atual
cat src/main/kotlin/com/moversemais/objective/controller/ObjectiveController.kt

# Estudar DTOs atuais
cat src/main/kotlin/com/moversemais/objective/dto/CreateObjectiveRequest.kt
cat src/main/kotlin/com/moversemais/objective/dto/UpdateObjectiveRequest.kt
cat src/main/kotlin/com/moversemais/objective/dto/ObjectiveResponse.kt

# Estudar UseCases
cat src/main/kotlin/com/moversemais/objective/usecase/CreateObjectiveUseCase.kt
cat src/main/kotlin/com/moversemais/objective/usecase/GetObjectiveUseCase.kt

# Estudar DTOs do Card 035
cat src/main/kotlin/com/moversemais/objective/dto/goals/GoalPlanDTO.kt

# Estudar Mappers
cat src/main/kotlin/com/moversemais/objective/mapper/ObjectiveMapper.kt
```

**Perguntas para Responder:**
- CreateObjectiveRequest: adicionar campos ou criar DTO novo?
- ObjectiveResponse: incluir plano completo ou criar DTO separado?
- Reutilizar DTOs do Card 035 (GoalPlanDTO)?
- Atualizar Mappers ou criar novos?
- UseCases: adicionar l√≥gica ou criar novos?

### **2. CRIAR BRANCH**

```bash
git checkout -b feature/goals-update-endpoints
```

### **3. IMPLEMENTAR (VOC√ä DECIDE COMO)**

**Voc√™ √© o especialista em Spring Boot + Kotlin!**

**Ordem sugerida:**
1. Atualizar CreateObjectiveRequest (motive, context, mode)
2. Atualizar CreateObjectiveUseCase (l√≥gica de status DRAFT vs ACTIVE)
3. Atualizar UpdateObjectiveRequest (motive, context)
4. Atualizar UpdateObjectiveUseCase (permitir atualizar novos campos)
5. Atualizar ObjectiveResponse (motive, context, mode, stages, KRs)
6. Atualizar GetObjectiveUseCase (buscar plano completo)
7. Atualizar Mappers (se necess√°rio)
8. Testar

**Decis√µes t√©cnicas que voc√™ toma:**
- Estrutura dos DTOs
- Reutilizar DTOs do Card 035 ou criar novos
- L√≥gica de mapeamento (Entity ‚Üí DTO)
- Valida√ß√µes adicionais
- Queries (fetch joins ou separadas)
- Backward compatibility

**Mas DEVE seguir:**
- ‚úÖ Padr√£o Clean Architecture
- ‚úÖ Padr√£o de DTOs existentes
- ‚úÖ Padr√£o de UseCases existentes
- ‚úÖ N√£o quebrar endpoints existentes

### **4. TESTAR**

**Testes Obrigat√≥rios:**

```bash
# 1. Rodar aplica√ß√£o
./gradlew bootRun

# 2. Testar POST /objectives (criar com Goal Chunking)
curl -X POST http://localhost:8080/api/v1/objectives \
  -H "X-User-Id: {userId}" \
  -H "Content-Type: application/json" \
  -d '{
    "objectiveText": "Correr 5km em 30 minutos",
    "startDate": "2025-11-08T00:00:00",
    "endDate": "2026-02-08T00:00:00",
    "objectiveType": "HEALTH_GOAL",
    "motive": "Melhorar sa√∫de e disposi√ß√£o",
    "context": "Treinar 3x por semana, 30min",
    "mode": "AUTO"
  }'

# Esperado: 201 Created
# Response: {id, status: DRAFT, mode: AUTO, motive, context}

# 3. Testar POST /objectives (criar sem Goal Chunking)
curl -X POST http://localhost:8080/api/v1/objectives \
  -H "X-User-Id: {userId}" \
  -H "Content-Type: application/json" \
  -d '{
    "objectiveText": "Aprender Kotlin",
    "startDate": "2025-11-08T00:00:00",
    "endDate": "2026-02-08T00:00:00",
    "mode": "MANUAL"
  }'

# Esperado: 201 Created
# Response: {id, status: ACTIVE, mode: MANUAL}

# 4. Testar GET /objectives/{id} (buscar com plano)
curl http://localhost:8080/api/v1/objectives/{id} \
  -H "X-User-Id: {userId}"

# Esperado: 200 OK
# Response: {
#   id, title, motive, context, mode,
#   stages: [{id, title, actions: [...]}],
#   keyResults: [{id, title, type, targetValue, ...}]
# }

# 5. Testar GET /objectives/{id} (buscar sem plano)
curl http://localhost:8080/api/v1/objectives/{id-sem-plano} \
  -H "X-User-Id: {userId}"

# Esperado: 200 OK
# Response: {id, title, motive, context, mode, stages: [], keyResults: []}

# 6. Testar PUT /objectives/{id} (atualizar motive/context)
curl -X PUT http://localhost:8080/api/v1/objectives/{id} \
  -H "X-User-Id: {userId}" \
  -H "Content-Type: application/json" \
  -d '{
    "motive": "Novo motivo atualizado",
    "context": "Novo contexto atualizado"
  }'

# Esperado: 200 OK
# Response: {id, motive: atualizado, context: atualizado}

# 7. Testar GET /objectives (lista)
curl http://localhost:8080/api/v1/objectives \
  -H "X-User-Id: {userId}"

# Esperado: 200 OK
# Response: [{id, title, motive, context, mode}, ...]
# N√ÉO deve incluir stages/KRs (muito pesado)

# 8. Testar backward compatibility (meta antiga)
# Metas criadas antes do Card 034 (sem motive, context, mode)
# Devem continuar funcionando

curl http://localhost:8080/api/v1/objectives/{id-antigo} \
  -H "X-User-Id: {userId}"

# Esperado: 200 OK
# Response: {id, title, motive: null, context: null, mode: MANUAL (default)}
```

**Verifica√ß√µes:**
- [ ] POST /objectives aceita motive, context, mode
- [ ] POST mode=AUTO cria com status=DRAFT
- [ ] POST mode=MANUAL cria com status=ACTIVE
- [ ] GET /objectives/{id} retorna plano completo (stages, KRs)
- [ ] GET /objectives/{id} sem plano retorna arrays vazios
- [ ] PUT /objectives/{id} atualiza motive, context
- [ ] GET /objectives (lista) inclui novos campos
- [ ] Backward compatibility (metas antigas funcionam)
- [ ] Build compilado
- [ ] Aplica√ß√£o iniciou

### **5. DOCUMENTAR DECIS√ïES**

Ao finalizar, documente:
- DTOs criados/atualizados
- UseCases modificados
- L√≥gica de mapeamento
- Queries usadas (fetch joins?)
- Testes realizados
- Dificuldades encontradas

### **6. COMMIT E PUSH**

```bash
git add .
git commit -m "feat(objective-service): atualiza endpoints para Goal Chunking

- CreateObjectiveRequest: adiciona motive, context, mode
- CreateObjectiveUseCase: l√≥gica DRAFT vs ACTIVE por mode
- UpdateObjectiveRequest: adiciona motive, context
- UpdateObjectiveUseCase: permite atualizar novos campos
- ObjectiveResponse: adiciona motive, context, mode, stages, keyResults
- GetObjectiveUseCase: busca plano completo (stages, actions, KRs)
- StageDTO, ActionDTO, KeyResultDTO (se criados)
- Mappers atualizados
- Backward compatibility mantida
- Testes realizados
- Ref: Card 036.2"

git push origin feature/goals-update-endpoints
```

### **7. MOVER PARA VALIDA√á√ÉO**

```bash
mv Development/TODO/036.2__Objective-Service-Update-Endpoints-For-Goal-Chunking.md \
   Development/VALIDATING/036.2__Objective-Service-Update-Endpoints-For-Goal-Chunking.md
```

---

## ‚úÖ CRIT√âRIOS DE VALIDA√á√ÉO

### **Funcionalidades:**
- [ ] POST /objectives aceita motive, context, mode
- [ ] Modo AUTO cria objective com status=DRAFT
- [ ] Modo MANUAL cria objective com status=ACTIVE
- [ ] GET /objectives/{id} retorna plano completo
- [ ] GET /objectives/{id} sem plano retorna arrays vazios
- [ ] PUT /objectives/{id} atualiza motive, context
- [ ] Listagens incluem novos campos
- [ ] Backward compatibility mantida

### **Padr√£o:**
- [ ] Seguiu Clean Architecture
- [ ] Seguiu padr√£o de DTOs
- [ ] Seguiu padr√£o de UseCases
- [ ] C√≥digo limpo e documentado
- [ ] Build compilado
- [ ] Aplica√ß√£o iniciou

### **Performance:**
- [ ] GET /objectives/{id} n√£o causa N+1 queries
- [ ] Listagens continuam r√°pidas (sem plano completo)

---

## üö® TROUBLESHOOTING

### **Problema: N+1 queries**
**Solu√ß√£o:**
- Usar fetch joins nas queries
- Ou queries separadas otimizadas
- Verificar logs do Hibernate

### **Problema: Metas antigas quebram**
**Solu√ß√£o:**
- Campos novos s√£o nullable (motive, context)
- mode tem DEFAULT 'MANUAL' no banco
- DTOs devem tratar null adequadamente

### **Problema: Response muito grande**
**Solu√ß√£o:**
- GET /objectives/{id}: incluir plano completo (OK)
- GET /objectives (lista): N√ÉO incluir plano (apenas campos b√°sicos)

---

## üéØ EXPECTATIVAS

### **Voc√™ √© o Especialista em Backend**

**Osvaldo, voc√™ completou 7 cards com EXCEL√äNCIA!** üèÜ

**Agora, voc√™ vai integrar Goal Chunking nos endpoints existentes!**

**Eu confio que voc√™:**
- Conhece os endpoints existentes (voc√™ mant√©m essa aplica√ß√£o!)
- Sabe atualizar DTOs e UseCases
- Sabe fazer queries eficientes (fetch joins)
- Sabe manter backward compatibility

**Eu defini O QUE precisa ser feito. Voc√™ decide COMO fazer.**

**Este card completa a integra√ß√£o de Goal Chunking no backend!** üöÄ

---

## üìä OUTPUT ESPERADO

Ao finalizar, documente aqui:

### **Decis√µes T√©cnicas Tomadas:**
(Voc√™ preenche)

### **DTOs Criados/Atualizados:**
(Liste)

### **UseCases Modificados:**
(Liste mudan√ßas)

### **Queries Usadas:**
(Fetch joins? Queries separadas?)

### **Testes Realizados:**
(Liste cen√°rios testados)

### **Dificuldades Encontradas:**
(Se houver)

### **Melhorias Implementadas:**
(Al√©m do requisitado)

---

**Data de Cria√ß√£o:** 08/11/2025  
**Criado por:** Arquiobaldo (Arquiteto MoverseMais)  
**Contexto:** M√≥dulo Goals - Atualizar Endpoints para Goal Chunking  
**Depend√™ncia:** Card 035 ‚úÖ (DONE), Card 036 ‚úÖ (DONE)  
**Pr√≥ximo:** Card 037 (BFF - Gabriela)  
**Vers√£o:** 1.0

